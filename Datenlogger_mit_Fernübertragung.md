.\" Automatically generated by Pandoc 1.16.0.2
.\"
.TH "" "" "" "" ""
.hy
.PP
Am Lehrstuhl an dem ich arbeite fahren die Kollegen regelmäßig raus, um
Datenlogger auszulesen.
Das ist natürlich aufwändig.
Ausserdem, wenn man nur einmal im Monat die Daten abholt, oder einmal
die Woche, kann man schonmal feststellen, dass der Logger oder das
Messgerät irgendwann ausgefallen ist.
Im schlimmsten Falle direkt nachdem man das letzte mal da war.
Wenn dadurch Messreihen unterbrochen werden ist das immer ärgerlich.
.PP
Ich frage mich, warum in Zeiten, wo an den meisten Stellen UMTS
verfügbar ist, solche fernübertragenden Datenlogger noch nicht
installiert sind.
Selbst nicht am
Hühnerwasser (http://www.tu-cottbus.de/projekte/de/ecosystem/wassereinzugsgebiet-huehnerwasser.html),
wo haufenweise Messgeräte stehen.
Bestimmt liegt das daran, dass kommerzielle Datenlogger sehr teuer sind.
Und dass die meisten nicht wissen, das es heute billige Minicomputer wie
die den Raspberry Pi (http://de.wikipedia.org/wiki/Raspberry_Pi) gibt,
die prima für so eine Aufgabe geeignet sind.
Und dann muss man sich natürlich ein bisschen reinfuchsen, wie man aus
einem Raspberry Pi einen Datenlogger mit Fernübertragung macht.
.PP
An den Messstellen, die ich kenne, gibt es folgende Vorraussetzungen:
.IP \[bu] 2
Messsignal über serielle Schnittstelle
.IP \[bu] 2
Stromversorgung entweder 220V oder 12V aus Batterie, die mit einem
Solarpanel aufgeladen wird
.SH TODO
.IP \[bu] 2
Raspberry Pi mit serieller Schnittstelle ausstatten (entweder über
USB\-Adapter oder über die GPIO\-Pins) [erledigt]
.RS 2
.IP \[bu] 2
habe ich jetzt mit einem USB\-Adapter gemacht
.RE
.IP \[bu] 2
Skript zum Ansprechen und auslesen des Messgerätes schreiben, dass
automatisch gestartet wird, wenn der Raspberry bootet [50% erledigt, mit
Fehlern]
.RS 2
.IP \[bu] 2
Das automatische Starten der Seriellen Verbindung zum Messgerät nach
Anschluss des USB\-Serial\-Adapters funktioniert noch nicht reibungslos.
Das Auslesen brach immer wieder ab.
Warum genau ist aber noch unklar.
Eventuell haben andere USB\-Geräte wie der UMTS\-Stick die Kommunikation
gestört, vor allem weil dieser sich immer wieder an\- und abzumelden
scheint.
Ich bräuchte vor allem mal ein Gerät, mit dem ich das in meinem Büro
testen kann.
Brauche nämlich die Nähe zum Internet, um nach möglichen Lösungsansätzen
zu suchen ;\-)
.RE
.IP \[bu] 2
UMTS\-Stick installieren [erledigt]
.RS 2
.IP \[bu] 2
funktioniert mit sakis3G (https://github.com/trixarian/sakis3g-source)
und läuft besser als die Vodafone\-Software auf meinem Mac.
.IP \[bu] 2
um UMTS\-Kosten zu sparen sollte man sich überlegen, bei welcher
Datenmenge sich der Verbindungsaufbau zur Dropbox lohnt.
Es werden nämlich eine ganze Menge Daten verschickt, bevor die
Verbindung überhaupt erstmal besteht.
Eventuell wäre z.B.
FTP auch weniger Datenintensiv.
.RE
.IP \[bu] 2
Skript schreiben, dass die IP des Raspberry einem korrespondierenden
Server bekannt macht (damit man im Notfall den Raspberry ansprechen per
SSH kann, wenn der sich nicht mehr meldet oder Einstellungen vorgenommen
werden müssen) [im Grunde erledigt, aber nicht ganz zufriedenstelltend]
.RS 2
.IP \[bu] 2
Eine wirkliche IP\-Adresse gibt es nicht im UMTS\-Netz.
Lösung war jetzt ein reverse ssh
tunnel (http://debianforum.de/forum/viewtopic.php?f=32&t=143011).
Dazu braucht man allerdings wieder einen Server oder Computer, der über
seine IP frei im Internet erreichbar ist.
Also geht eine Verbindung direkt ins Uni\-Netz leider nicht.
.IP \[bu] 2
Eine gut funktionierende Lösung war, die Daten in eine Dropbox hoch zu
laden.
Das habe ich auch so eingerichtet, dass der Pi in der Dropbox nach einem
Schell\-Script mit einem bestimmten Namen schaut in die man den Befehl
zum aufbauen des revers tunnel schreiben kann.
Oder irgend ein anderes Wartungs\-Script.
.RE
.IP \[bu] 2
Skript schreiben, dass alle paar Minuten oder Stunden die Daten
verschickt (Cron\-Job) [erledigt]
.RS 2
.IP \[bu] 2
Daten werden gezippt und unter dem Datum gespeichert.
Dann wird die Zip in die Dropbox hochgeladen und nach erfolgreichem
hochladen gelöscht.
Wenn die Dropbox\-Verbindung nicht aufgebaut werden kann, sammeln die
Zip\-Dateien sich im Ordner an und können z.B.
über USB abgeholt werden.
Wenn die Dropbox\-Verbindung das nächste mal erfolgreich ist, werden
alle Zip\-Dateien im Ordner hochgeladen (auch die, die das letzte mal
nicht geladen werden konnten).
.IP \[bu] 2
Eventuell lieber Owncloud oder FTP auf dem fablab\-Server benutzen.
Dann müssen die Daten nicht nach Amerika geschickt werden ;\-)
.RE
.IP \[bu] 2
Routine für das Auslesen per USB schreiben (automatischer Datensync,
wenn USB\-Stick angeschlossen wird) [erledigt]
.RS 2
.IP \[bu] 2
udev\-Regel reagiert, wenn der USB\-Stick angeschlossen wird und startet
ein Skript zum Kopieren.
Die udev\-Regel kann auch nur auf einen bestimmten USB\-Stick
eingestellt werden (über dessen Seriennummer).
.IP \[bu] 2
Auch auf den Stick kann ein Shell\-Script gelegt werden, dass beim
Anschluss des USB\-Sticks ausgeführt wird.
.IP \[bu] 2
Beim Anschluss des USB\-Sticks werden bisher nicht die Daten vom
Datenlogger gelöscht, da man nicht weiß, ob der USB\-Stick nicht
unterwegs verloren gehen könnte.
Das Löschen der Dateien könnte man dann in das Shell\-Script schreiben,
sodass die erfolgreich Übertragenen Daten beim nächsten Abholen gelöscht
werden.
.RE
.IP \[bu] 2
12V\-Stromversorgung (Eventuell über Autonetzteil) [0% erledigt]
.PP
Der Datenlogger sollte eine hohe Redundanz haben, damit ja keine Daten
verloren gehen.
.IP \[bu] 2
Mehre Auslesewege (UMTS, USB\-Stick, Auslesung mit Laptop über LAN)
.IP \[bu] 2
keine Daten löschen, bevor nicht bestätigt wurde, dass sie ausgelesen
wurden und sicher irgendwo angekommen sind
.PP
Dann sollte der Datenlogger automatisch Warnungen verschicken, wenn die
Batteriespannung zu gering, der Datenspeicher voll ist oder das
Messgerät nicht mehr arbeitet.
.PP
Man muss sich natürlich auch noch Gedanken machen, wie man den Raspberry
wetterfest macht.
Manchmal könnte man ihn in bestehende Kästen integrieren, manchmal
bräuchte man aber auch ein Gehäuse wie z.B.
dieses
hier (https://www.kickstarter.com/projects/1821240043/pice-the-ultimate-case-for-your-raspberry-pi-and-c).
.SH Was bringt das dem fablab?
.IP \[bu] 2
Ein tolles Bastelprojekt
.IP \[bu] 2
Ein Vorzeigeprojekt
.IP \[bu] 2
Eine erste Bastelanleitung, die wir in unserem Wiki veröffentlichen
können
.IP \[bu] 2
Ein Ergebnis, dass einige Lehrstühle hier an der Uni gut gebrauchen
können
.IP \[bu] 2
Deswegen auch wahrscheinlich Unterstützung bzw.
Spenden von entsprechenden Lehrstühlen
.IP \[bu] 2
Ein Ergebnis, dass vielleicht auch woanders Interessenten findet
.IP \[bu] 2
Folgeprojekte?
.SH Diskussion
.SH Übersicht momentane Lösung
.PP
In seinem jetzigen Stand erledigt der Raspberry als Datenlogger drei
Aufgaben:
.IP "1." 3
Kommunikation mit dem Messgerät herstellen und Daten loggen
.IP "2." 3
Bei Anschluss eines USB\-Stick Daten auf Stick kopieren
.IP "3." 3
Wenn ein Internet\-Stick angeschlossen ist Internetverbindung herstellen
und Dropbox\-upload
.PP
Hier ein Überblick über die Herausforderungen und die gefundenen
Lösungen:
.IP \[bu] 2
USB\-Geräte erkennen und entsprechende Skripte starten → Lösung:
UDEV\-Regeln (http://wiki.ubuntuusers.de/udev)
.IP \[bu] 2
Serielle Kommunikation zum Messgerät herstellen →
\f[C]stty\f[] (http://unixhelp.ed.ac.uk/CGI/man-cgi?stty),
Kommunikationseinstellungen spezifisch für jedes Gerät
.IP \[bu] 2
Messgerät konfigurieren (vor allem Uhrzeit stellen) → \f[C]echo\f[]
\f[C]\-e\f[] (http://unixhelp.ed.ac.uk/CGI/man-cgi?echo) (\f[C]\-e\f[]
to enable interpretation of backslash escapes), Befehle nach Handbuch
.IP \[bu] 2
Eingehende Daten in Datei umleiten →
\f[C]cat\f[] (http://unixhelp.ed.ac.uk/CGI/man-cgi?cat)
\f[C]/dev/USB\-Serial\-Port\f[] \f[C]>>\f[] \f[C]Datei.txt\f[]
.SH Erläuterung der momentanen Lösung
.PP
Um zu verstehen was der Datenlogger macht und wie man die Skripte
anpassen kann, muss man sich vor allem in drei Themenfelder einarbeiten:
.IP "1." 3
Grundsätzlich: wie schreibt man Shell\-Skripte?
.IP "2." 3
Wie schreibt man UDEV\-Regeln?
.IP "3." 3
Wie kann man aus der Shell über die serielle Schnittstelle (RS\-232) mit
einem Gerät kommunizieren?
.PP
Zum Schreiben von UDEV\-Regeln gibt es unter
hier (http://wiki.ubuntuusers.de/udev) eine schöne Anleitung.
Über die Serielle Schnittstelle hat
hier (http://papers.mpastell.com/serial.pdf) jemand eine kurze und gut
verständliche Anleitung zusammen gestellt.
.PP
Zum Aufbau eines Shell\-Skriptes sollte man folgendes wissen:
.PP
Die erste Zeile des Skripts muss lauten:
.PP
\f[C]\ #!/bin/bash\f[]
.PP
Diese sogenannte Shebang\-Zeile (https://de.wikipedia.org/wiki/Shebang)
macht das Shell\-Skript überhaupt erst als solches erkennbar.
.PP
Da die Skripte später nicht mehr vom User direkt, sondern von den
UDEV\-Regeln oder Cron\-Jobs aufgerufen werden sollen, lohnt sich die
Umleitung aller Meldungen in eine Log\-Datei.
Dies wird am besten direkt in den nächten beiden Zeilen veranlasst:
.PP
\f[C]logfile=/home/pi/logs/usb\-serial\-log.log\ &&\f[]
.PD 0
.P
.PD
\f[C]exec\ >>\ $logfile\ 2>&1\f[]
.PP
Nun werden Fehlermeldungen in die definierte Datei geschrieben.
Ausserdem kann man mit \f[C]echo\f[] Kommentare über den (reibungslosen)
Ablauf des Skripts in die Log\-Datei schreiben.
So zum Beispiel:
.PP
\f[C]echo\ \-e\ Connecting\ to\ parsivel\ distrometer\ $(date\ +"%F\ %X")\f[]
.PP
Alles was normalerweise an den User ausgegeben wird, wird nun in die
Log\-Datei geschrieben.
.PP
Kommandozeilen in Shell\-Skripten sind grundsätzlich wie folgt
aufgebaut: Das erste Wort ist der Befehl, gefolgt von den Optionen, die
meist mit \-e beginnen.
Der Befehl \f[C]cat\f[] kann zum Beispiel den Inhalt einer Datei
anzeigen:
.PP
\f[C]cat\ \-n\ MeinText.txt\f[]
.PP
Die Option \f[C]\-n\f[] sorgt dabei dafür, dass eine Zeilennummerierung
dargestellt wird.
.PP
Das Ergebnis eines Befehls kann mit \f[C]>\f[] umgeleitet werden.
Zum Beispiel in eine Datei:
.PP
\f[C]cat\ alte_Datei.txt\ >\ neue_Datei.txt\f[]
.PP
Da die Kommunikation, die von der seriellen Schnittstelle kommt genauso
zu handhaben ist wie eine Datei, können wir mit:
.PP
\f[C]cat\ /dev/USB\-Serial\-Port\ >>\ /home/pi/Documents/Loggerdaten/Loggerdaten.txt\f[]
.PP
einkommende Daten in eine Datei schreiben.
\f[C]>>\f[] statt \f[C]>\f[] sorgt dabei dafür, dass neue Daten an die
Datei angehängt werden und nicht ihren Inhalt ersetzen.
.PP
Um diesen Befehl im Hintergrund laufen zu lassen fügt man \f[C]&\f[] an
den Befehl an:
.PP
\f[C]cat\ /dev/USB\-Serial\-Port\ >>\ /home/pi/Documents/Loggerdaten/Loggerdaten.txt\ &\f[]
.PP
Verwendet man als nächste Zeile
.PP
\f[C]MeineProzessNR=$!\f[]
.PP
hat man die Prozessnummer (PID) in einer Variablen gespeichert, um
später mit
.PP
\f[C]kill\ $MeineProzessNR\f[]
.PP
den Prozess wieder beenden zu können.
Die PID kann man natürlich auch in eine Datei schreiben, um den Prozess
mit einem anderen Skript wieder beenden zu können.
.PP
Für gewöhnlich bauen die Kommandos eines Skriptes aufeinander auf.
Das heißt das die nächste Kommandozeile das erfolgreiche abarbeiten der
vorangehenden Kommandozeile voraussetzt.
Um zu vermeiden, dass die nächste Zeile (bzw.
der ganze Rest des Skriptes) ausgeführt wird, wenn ein Teil davon nicht
funktioniert, muss jedes Kommando von einem \f[C]&&\f[] gefolgt werden.
\f[C]&&\f[] sorgt dafür, dass das Skript nur fortgesetzt wird, wenn das
davorstehende Kommando \f[C]0\f[] zurück gibt.
Jede andere Rückgabe bedeutet einen Fehler.
Systemkommandos sind alle so eingestellt, dass sie \f[C]0\f[] zurück
geben, wenn sie erfolgreich ausgeführt wurden und ansonsten einen
Fehlercode übergeben.
In eigenen Skripts kann man das genauso umsetzen.
Mit
.PP
\f[C]exit\ 0\f[]
.PP
beendet man sein Skript und signalisiert, dass die Ausführung
erfolgreich war.
Somit würde ein ganz simples Skript also so aussehen:
.PP
\f[C]#!/bin/bash\f[]
.PD 0
.P
.PD
\f[C]cat\ TestDatei.txt\ &&\f[]
.PD 0
.P
.PD
\f[C]echo\ Hallo\ Welt\ &&\f[]
.PD 0
.P
.PD
\f[C]exit\ 0\f[]
.PP
Wenn Zeile zwei nicht ausgeführt werden kann (z.B.
weil die Datei TestDatei.txt nicht vorhanden ist), wird auch der Rest
des Skripts nicht ausgeführt.
Da auch \f[C]exit\f[] \f[C]0\f[] nicht ausgeführt wird, ist klar, dass
das Skript nicht erfolgreich bis zu Ende ausgeführt wurde.
.PP
Dabei muss man beachten, dass das Starten von Hintergrundprozessen das
nacheinander abarbeiten der Kommandos mit \f[C]&&\f[] unterbricht und zu
unvorhergesehenen Ergebnissen führt.
Das Ausführen von:
.PP
\f[C]echo\ eins\ &&\ \f[]
.PD 0
.P
.PD
\f[C]sleep\ 5\ &&\ echo\ zwei\ &\ \f[]
.PD 0
.P
.PD
\f[C]echo\ drei\ &&\ \f[]
.PD 0
.P
.PD
\f[C]echo\ vier\f[]
.PP
zum Beispiel führt zu der Ausgabe:
.PP
\f[C]drei\f[]
.PD 0
.P
.PD
\f[C]vier\f[]
.PD 0
.P
.PD
\f[C]eins\f[]
.PD 0
.P
.PD
\f[C]zwei\f[]
.PP
Abhilfe schafft hier Klammersetzung:
.PP
\f[C]echo\ eins\ &&\f[]
.PD 0
.P
.PD
\f[C](sleep\ 5\ &&\ echo\ zwei\ &)\f[]
.PD 0
.P
.PD
\f[C]echo\ drei\ &&\f[]
.PD 0
.P
.PD
\f[C]echo\ vier\f[]
.PP
Hier kann man die Prozessnummer wie folgt speichern:
.PP
\f[C]echo\ eins\ &&\f[]
.PD 0
.P
.PD
\f[C]pid=$(sleep\ 5\ &&\ echo\ zwei\ &\ echo\ $!)\f[]
.PD 0
.P
.PD
\f[C]echo\ drei\ &&\f[]
.PD 0
.P
.PD
\f[C]echo\ vier\f[]
.PP
Auf diese Weise wurde z.B.
folgende Zeile im Skript \f[C]usb\-serial.sh\f[] umgesetzt:
.PP
\f[C]pid=$(\ cat\ /dev/USB\-Serial\-Port\ >>\ $logfile\ &\ echo\ $!\ )\f[]
.SH Verwendete Skripte
.SS Installation
.IP \[bu] 2
sakis3G (https://github.com/trixarian/sakis3g-source) herunterladen und
kompilieren.
.IP \[bu] 2
Dropbox Sync
installieren (http://raspi.tv/2013/how-to-use-dropbox-with-raspberry-pi)
.PP
\f[C]\ #\ make\ dropbox\ available\ systemwide:\f[]
.PD 0
.P
.PD
\f[C]\ sudo\ ln\ \-s\ /home/pi/Scripts/Dropbox\-Uploader/dropbox_uploader.sh\ /usr/bin/dropbox\f[]
.PD 0
.P
.PD
\f[C]\ #\ same\ for\ sakis3g\f[]
.PD 0
.P
.PD
\f[C]\ sudo\ ln\ \-s\ /home/pi/Scripts/sakis3g\ /usr/bin/sakis3g\f[]
.PP
Die UDEV\-Regeln müssen als Datei in \f[C]/etc/udev/rules.d\f[] angelegt
werden.
Man kann alle Regeln in eine Datei legen.
Eventuell macht man auch einen Symlink in den Ordner wo man alle Skripte
zentral zu liegen hat.
.SS online upload
.SS UDEV\-Regel beim Anschluss des USB\-Modems:
.PP
Einfach nur, um dem Gerät einen immer gleichen Namen zu geben:
.PP
\f[C]\ ATTRS{idProduct}==\f[]\[lq]\f[C]1003\f[]\[rq]\f[C],\ ATTRS{idVendor}==\f[]\[lq]\f[C]12d1\f[]\[rq]\f[C],\ ATTRS{bInterfaceNumber}==\f[]\[lq]\f[C]00\f[]\[rq]\f[C],\ ACTION==\f[]\[lq]\f[C]add\f[]\[rq]\f[C],\ SYMLINK+=\f[]\[lq]\f[C]umts0\f[]\[rq]
.PP
Um die Verbindung aufzubauen, sobald das Modem vollständig erkannt ist:
.PP
\f[C]\ #ATTRS{idVendor}==\f[]\[lq]\f[C]Huawei\f[] \f[C]Technologies\f[]
\f[C]Co.,\f[]
\f[C]Ltd.\f[]\[rq]\f[C],\ ATTRS{idProduct}==\f[]\[lq]\f[C]E220\f[]
\f[C]HSDPA\f[] \f[C]Modem\f[] \f[C]/\f[] \f[C]E230/E270/E870\f[]
\f[C]HSDPA/HSUPA\f[] \f[C]Modem\f[]\[rq]
.PD 0
.P
.PD
\f[C]\ #ATTRS{bInterfaceNumber}==\f[]\[lq]\f[C]01\f[]\[rq]\f[C],\f[]
.PD 0
.P
.PD
\f[C]\ #KERNEL==\f[]\[lq]\f[C]ttyUSB?\f[]\[rq]\f[C],\ SUBSYSTEMS==\f[]\[lq]\f[C]usb\f[]\[rq]\f[C],\ ATTRS{idProduct}==\f[]\[lq]\f[C]1003\f[]\[rq]\f[C],\ ATTRS{bInterfaceNumber}==\f[]\[lq]\f[C]01\f[]\[rq]\f[C],\ ACTION==\f[]\[lq]\f[C]add\f[]\[rq]\f[C],\ RUN+="/home/pi/test.sh"\f[]
.PD 0
.P
.PD
\f[C]\ \f[]
.PD 0
.P
.PD
\f[C]\ KERNEL==\f[]\[lq]\f[C]ttyUSB*\f[]\[rq]\f[C],\ SUBSYSTEM==\f[]\[lq]\f[C]tty\f[]\[rq]\f[C],\ ATTRS{bInterfaceNumber}==\f[]\[lq]\f[C]01\f[]\[rq]\f[C],\ ACTION==\f[]\[lq]\f[C]add\f[]\[rq]\f[C],\ RUN+="/home/pi/Scripts/3Gconnect.sh"\f[]
.PD 0
.P
.PD
\f[C]\ \f[]
.PD 0
.P
.PD
\f[C]\ #,\ ATTRS{idProduct}==\f[]\[lq]\f[C]1003\f[]\[rq]\f[C],\ ATTRS{idVendor}==\f[]\[lq]\f[C]12d1\f[]\[rq]\f[C],\f[]
.SS 3Gconnect.sh
.PP
Aufbau der 3G\-Verbindung
.PP
\f[C]\ #!/bin/bash\f[]
.PD 0
.P
.PD
\f[C]\ \f[]
.PD 0
.P
.PD
\f[C]\ logfile=/home/pi/logs/3Gconnect_$$.log\f[]
.PD 0
.P
.PD
\f[C]\ exec\ >\ $logfile\ 2>&1\f[]
.PD 0
.P
.PD
\f[C]\ #sleep\ 10s\f[]
.PD 0
.P
.PD
\f[C]\ sudo\ sakis3g\ SIM_PIN=\f[]\f[C]\ APN=internet.eplus.de\ connect\f[]
.SS cron\-job zum starten des Dropbox Sync
.PP
\f[C]crontab\f[] \f[C]\-e\f[] zum editieren der cron\-jobs.
Folgende Zeilen einfügen:
.PP
\f[C]\ 0\ 7\-20\ \ \ *\ *\ *\ \ \ /home/pi/Scripts/cron\-dropbox\-sync.sh\f[]
.PD 0
.P
.PD
\f[C]\ \@reboot\ \ /home/pi/Scripts/cron\-dropbox\-sync.sh\f[]
.SS cron\-dropbox\-sync.sh
.PP
Synchronisiert mit der Dropbox
.PP
\f[C]#!/bin/bash\f[]
.PD 0
.P
.PD
.PD 0
.P
.PD
\f[C]logfile=/home/pi/logs/crontab\-dropbox\-sync_$$.log\f[]
.PD 0
.P
.PD
\f[C]exec\ >\ $logfile\ 2>&1\ \f[]
.PD 0
.P
.PD
.PD 0
.P
.PD
\f[C]cd\ /home/pi/Documents/Loggerdaten/\ &&\ \f[]
.PD 0
.P
.PD
.PD 0
.P
.PD
\f[C]timestamp=$(date\ +%Y_%m_%d\-%H_%M_%S)\ &&\f[]
.PD 0
.P
.PD
.PD 0
.P
.PD
\f[C]timestamp\ >>\ $logfile\f[]
.PD 0
.P
.PD
.PD 0
.P
.PD
\f[C]file=Loggerdaten_$timestamp.txt\f[]
.PD 0
.P
.PD
.PD 0
.P
.PD
\f[C]cp\ Loggerdaten.txt\ $file\ &&\f[]
.PD 0
.P
.PD
.PD 0
.P
.PD
\f[C]echo\ Fortsetzung\ der\ Messung\ $(date\ +"%F\ %T\ %Z")\ >\ Loggerdaten.txt\ &&\f[]
.PD 0
.P
.PD
.PD 0
.P
.PD
\f[C]gzip\ \-\-best\ $file\ &&\f[]
.PD 0
.P
.PD
.PD 0
.P
.PD
\f[C]sudo\ sakis3g\ SIM_PIN=1328\ APN=internet.eplus.de\ connect\f[]
.PD 0
.P
.PD
.PD 0
.P
.PD
\f[C]/home/pi/Dropbox\-Uploader/dropbox_uploader.sh\ upload\ Loggerdaten_*.gz\ Loggerdaten/\ &&\f[]
.PD 0
.P
.PD
.PD 0
.P
.PD
\f[C]rm\ Loggerdaten_*\f[]
.PD 0
.P
.PD
.PD 0
.P
.PD
\f[C]/home/pi/Scripts/cron\-dropbox\-execute.sh\f[]
.PD 0
.P
.PD
.PD 0
.P
.PD
\f[C]sudo\ sakis3g\ disconnect\f[]
.SS cron\-dropbox\-execute.sh
.PP
Führt das Shell\-Script aus, dass von der dropbox geladen wurde
.PP
\f[C]\ #!/bin/bash\f[]
.PD 0
.P
.PD
\f[C]\ cd\ /home/pi/executeScript\ &&\f[]
.PD 0
.P
.PD
\f[C]\ \f[]
.PD 0
.P
.PD
\f[C]\ /home/pi/Dropbox\-Uploader/dropbox_uploader.sh\ download\ executeScript/execute.sh\ ../\ &&\f[]
.PD 0
.P
.PD
\f[C]\ \f[]
.PD 0
.P
.PD
\f[C]\ chmod\ +x\ execute.sh\ &&\f[]
.PD 0
.P
.PD
\f[C]\ \f[]
.PD 0
.P
.PD
\f[C]\ ./execute.sh\ &&\f[]
.PD 0
.P
.PD
\f[C]\ \f[]
.PD 0
.P
.PD
\f[C]\ /home/pi/Dropbox\-Uploader/dropbox_uploader.sh\ delete\ executeScript/execute.sh\f[]
.PD 0
.P
.PD
\f[C]\ \f[]
.PD 0
.P
.PD
\f[C]\ /home/pi/Dropbox\-Uploader/dropbox_uploader.sh\ upload\ *\ executionLog/\ &&\f[]
.PD 0
.P
.PD
\f[C]\ \f[]
.PD 0
.P
.PD
\f[C]\ rm\ *\f[]
.SS execute.sh
.PP
Wenn man \f[C]execute.sh\f[] in den Ornder \[lq]executeScript\[rq] in
der Dorpbox legt, wird das Shell\-Skript beim Dropbox\-Sync ausgeführt
und daraufhin in den Ordner \[lq]executionLog\[rq] gelegt, zusammen mit
dem Log\-File der execution.
.PP
Die folgende Datei ruft Beispielhaft einen reverse ssh tunnel auf, um
den Raspberry live steuern zu können.
Der reverse tunnel öffnet den Port 2222 auf dem Server und leitet eine
eingehende ssh\-Verbindung an den Pi weiter.
Die Verbindung mit dem Raspberry stellt man also her mit \f[C]ssh\f[]
\f[C]\@\f[]\f[C]:2222\f[].
Arbeitet man auf dem Server can \[lq]localhost\[rq] anstatt der IP
verwendet werden.
.PP
\f[C]\ #!/bin/bash\f[]
.PD 0
.P
.PD
\f[C]\ \f[]
.PD 0
.P
.PD
\f[C]\ exec\ 1>>\ log.txt\ 2>&1\f[]
.PD 0
.P
.PD
\f[C]\ echo\ $(date)\f[]
.PD 0
.P
.PD
\f[C]\ \f[]
.PD 0
.P
.PD
\f[C]\ #\-f\ would\ be\ for\ background\f[]
.PD 0
.P
.PD
\f[C]\ ssh\ \-v\ \-N\ \-R\ 2222:localhost:22\ \f[]\f[C]\@\f[]\f[C]\ &\f[]
.PD 0
.P
.PD
\f[C]\ sshPID=$!\f[]
.PD 0
.P
.PD
\f[C]\ #\ hold\ the\ connection\ open\ for\ some\ time,\ then\ close\f[]
.PD 0
.P
.PD
\f[C]\ sleep\ 900\f[]
.PD 0
.P
.PD
\f[C]\ kill\ $sshPID\f[]
.SS USB download
.SS UDEV\-Regel:
.PP
Eventuell kann hier die Seriennummer auch weggelassen werden, wenn man
mit jedem beliebigen USB\-Stick zugreifen möchte
.PP
\f[C]ATTRS{idVendor}==\f[]\[lq]\f[C]0951\f[]\[rq]\f[C],\ ATTRS{idProduct}==\f[]\[lq]\f[C]1643\f[]\[rq]\f[C],\ ATTRS{serial}=="\f[]\f[C]",\ ACTION==\f[]\[lq]\f[C]add\f[]\[rq]\f[C],\ MODE=\f[]\[lq]\f[C]0755\f[]\[rq]\f[C],\ GROUP=\f[]\[lq]\f[C]plugdev\f[]\[rq]\f[C],\ OWNER=\f[]\[lq]\f[C]pi\f[]\[rq]\f[C],\ SUBSYSTEMS==\f[]\[lq]\f[C]usb\f[]\[rq]\f[C],\ SYMLINK+=\f[]\[lq]\f[C]commandstick\f[]\[rq]\f[C],\ RUN+="/home/pi/Scripts/mountCommandStick.sh"\f[]
.PD 0
.P
.PD
\f[C]ENV{DEVLINKS}=="/dev/commandstick",\ ACTION==\f[]\[lq]\f[C]remove\f[]\[rq]\f[C],\ RUN+="/home/pi/Scripts/unmount.sh"\f[]
.SS mountCommandStick.sh
.PP
Mountet den Commandstick
.PP
\f[C]#!/bin/bash\f[]
.PD 0
.P
.PD
\f[C]mkdir\ /media/commandstick\f[]
.PD 0
.P
.PD
\f[C]mount\ \-o\ uid=pi,gid=plugdev\ /dev/commandstick\ /media/commandstick\f[]
.PD 0
.P
.PD
.PD 0
.P
.PD
\f[C]/media/commandstick/command.sh\f[]
.SS command.sh
.PP
Kommandodatei auf dem Stick:
.PP
\f[C]#!/bin/bash\f[]
.PD 0
.P
.PD
.PD 0
.P
.PD
\f[C]logfile=/media/commandstick/logs/rsync.log\f[]
.PD 0
.P
.PD
\f[C]exec\ >>\ $logfile\ 2>&1\f[]
.PD 0
.P
.PD
.PD 0
.P
.PD
\f[C]cd\ /home/pi/Documents/Loggerdaten/\ &&\f[]
.PD 0
.P
.PD
.PD 0
.P
.PD
\f[C]timestamp=$(date\ +%Y_%m_%d\-%H_%M_%S)\ &&\f[]
.PD 0
.P
.PD
.PD 0
.P
.PD
\f[C]echo\ \-e\ "\\nProtokoll\ Auslesung"\ $timestamp\ "\\n"\f[]
.PD 0
.P
.PD
\f[C]df\ #to\ write\ free\ diskspace\ to\ log\ file\f[]
.PD 0
.P
.PD
\f[C]echo\ "\ "\f[]
.PD 0
.P
.PD
.PD 0
.P
.PD
\f[C]#file=Loggerdaten_$timestamp.txt\f[]
.PD 0
.P
.PD
\f[C]#cp\ Loggerdaten.txt\ $file\ &&\f[]
.PD 0
.P
.PD
\f[C]#echo\ Fortsetzung\ der\ Messung\ $(date\ +"%F\ %T\ %Z")\ >\ Loggerdaten.txt\ &&\ \f[]
.PD 0
.P
.PD
.PD 0
.P
.PD
.PD 0
.P
.PD
\f[C]#\ Datein\ auf\ den\ Stick\ kopieren:\f[]
.PD 0
.P
.PD
\f[C]rsync\ \-r\ /home/pi/Documents/Loggerdaten/\ /media/commandstick/Loggerdaten/\ \-v\f[]
.PD 0
.P
.PD
.PD 0
.P
.PD
\f[C]#\ logs\ auf\ den\ Stick\ kopieren:\f[]
.PD 0
.P
.PD
\f[C]rsync\ \-r\ /home/pi/logs/*\ /media/commandstick/logs/\ \-v\f[]
.PD 0
.P
.PD
.PD 0
.P
.PD
.PD 0
.P
.PD
\f[C]#\ diese\ Zeile\ auskommentiren\ um\ dei\ Daten\ auf\ dem\ Logger\ zu\ löschen:\f[]
.PD 0
.P
.PD
\f[C]#rm\ /home/pi/Documents/Loggerdaten/Loggerdaten.txt\f[]
.SS unmount.sh
.PP
Unmountet den Commandstick
.PP
\f[C]#!/bin/bash\f[]
.PD 0
.P
.PD
\f[C]logfile=/home/pi/logs/unmount_$$.log\f[]
.PD 0
.P
.PD
\f[C]exec\ >>\ $logfile\ 2>&1\f[]
.PD 0
.P
.PD
\f[C]umount\ /media/commandstick\f[]
.PD 0
.P
.PD
\f[C]rm\ \-r\ /media/commandstick\f[]
.SS Serielle Kommunikation
.PP
Viele Messgeräte besitzen eine serielle Schnittstelle (z.B.
HeliosMini
Wetterstation/Datenlogger (HeliosMini_Wetterstation/Datenlogger)).
In diesem Aufbau wird ein USB zu Seriell Adapter verwendet, um die
Kommunikation herzustellen.
Wenn dieser angeschlossen wird, wird eine UDEV\-Regel aktiviert:
.SS UDEV\-Regel:
.PP
\f[C]#\ this\ contains\ the\ rules\ to\ execute\ serial\ comminication\ with\ the\ Parsivel\f[]
.PD 0
.P
.PD
\f[C]ATTRS{idVendor}==\f[]\[lq]\f[C]067b\f[]\[rq]\f[C],\ SUBSYSTEMS==\f[]\[lq]\f[C]usb\f[]\[rq]\f[C],\ ATTRS{manufacturer}==\f[]\[lq]\f[C]Prolific\f[]
\f[C]Technology\f[]
\f[C]Inc.\f[]\[rq]\f[C],\ ATTRS{product}==\f[]\[lq]\f[C]USB\-Serial\f[]
\f[C]Controller\f[]\[rq]\f[C],\ ACTION==\f[]\[lq]\f[C]add\f[]\[rq]\f[C],\ SYMLINK+=\f[]\[lq]\f[C]USB\-Serial\-Port\f[]\[rq]\f[C],\ RUN+="/home/pi/Scripts/usb\-serial.sh"\f[]
.PD 0
.P
.PD
\f[C]\ \f[]
.PD 0
.P
.PD
\f[C]ENV{DEVLINKS}=="/dev/USB\-Serial\-Port",\ ACTION==\f[]\[lq]\f[C]remove\f[]\[rq]\f[C],\ RUN+="/home/pi/Scripts/usb\-serial\-remove.sh"\f[]
.PD 0
.P
.PD
.PD 0
.P
.PD
\f[C]#ATTRS{serial}==\f[]\[lq]\f[C]Prolific_Technology_Inc._USB\-Serial_Controller\f[]\[rq]
.SS usb\-serial.sh
.PP
Macht eine Pipe vom Seriellen Anschluss in die Datei
\[lq]Loggerdaten.txt\[rq].
.PP
\f[C]#!/bin/bash\f[]
.PD 0
.P
.PD
.PD 0
.P
.PD
\f[C]logfile=/home/pi/logs/usb\-serial\-log.log\ &&\f[]
.PD 0
.P
.PD
\f[C]exec\ >>\ $logfile\ 2>&1\f[]
.PD 0
.P
.PD
\f[C]echo\ \-e\ "\\nConnecting\ to\ parsivel\ distrometer"\ $(date\ +"%F\ %X")\ &&\f[]
.PD 0
.P
.PD
\f[C]#sudo\ \-u\ pi\ touch\ /home/pi/Documents/Loggerdaten/Loggerdaten.txt\f[]
.PD 0
.P
.PD
.PD 0
.P
.PD
\f[C]#for\ the\ HeliosMini\f[]
.PD 0
.P
.PD
\f[C]#stty\ \-F\ /dev/USB\-Serial\-Port\ speed\ 9600\ &&\f[]
.PD 0
.P
.PD
.PD 0
.P
.PD
\f[C]#for\ Parsivel:\f[]
.PD 0
.P
.PD
\f[C]#while\ !\ `tty\ \-s`;\ do\ sleep\ 3;\ done\f[]
.PD 0
.P
.PD
\f[C]#sleep\ 120\ #\ necessary\ to\ run\ properly\ at\ system\ start\f[]
.PD 0
.P
.PD
\f[C]#stty\ \-F\ /dev/USB\-Serial\-Port\ speed\ 19200\ &&\f[]
.PD 0
.P
.PD
\f[C]#\ repeated\ because\ the\ first\ time\ doesnt\ work\ on\ boot\ (don\[aq]t\ know\ why)\f[]
.PD 0
.P
.PD
.PD 0
.P
.PD
\f[C]stty\ \-F\ /dev/USB\-Serial\-Port\ speed\ 19200\ raw\ &&\f[]
.PD 0
.P
.PD
\f[C]stty\ \-F\ /dev/USB\-Serial\-Port\ \-inlcr\ \-icrnl\ \-imaxbel\ \-opost\ onlcr\ \-isig\ \-icanon\ \-echo\ &&\f[]
.PD 0
.P
.PD
.PD 0
.P
.PD
\f[C]#\ Return\ von\ Parsivel\ in\ logdatei\ schreiben\f[]
.PD 0
.P
.PD
\f[C]pid=$(\ cat\ /dev/USB\-Serial\-Port\ >>\ $logfile\ &\f[]
.PD 0
.P
.PD
\f[C]echo\ $!\ )\ &&\f[]
.PD 0
.P
.PD
\f[C]sleep\ 1\ &&\f[]
.PD 0
.P
.PD
\f[C]#echo\ $pid\ &&\f[]
.PD 0
.P
.PD
.PD 0
.P
.PD
\f[C]#\ turn\ sdi\-12\ mode\ off:\f[]
.PD 0
.P
.PD
\f[C]echo\ turn\ sdi\-12\ mode\ off\ &&\f[]
.PD 0
.P
.PD
\f[C]echo\ \-e\ \f[]\[lq]\f[C]CS/S/E/0\\r\f[]\[rq]\f[C]\ >\ /dev/USB\-Serial\-Port\ &&\f[]
.PD 0
.P
.PD
\f[C]sleep\ 1\ &&\f[]
.PD 0
.P
.PD
.PD 0
.P
.PD
\f[C]#\ turn\ poll\ mode\ on\ for\ settings:\f[]
.PD 0
.P
.PD
\f[C]echo\ \f[]\[lq]\f[C]turn\f[] \f[C]poll\f[] \f[C]mode\f[]
\f[C]on\f[] \f[C]for\f[] \f[C]settings\f[]\[rq]\f[C]\ &&\f[]
.PD 0
.P
.PD
\f[C]echo\ \-e\ \f[]\[lq]\f[C]CS/I/0\\r\f[]\[rq]\f[C]\ >\ /dev/USB\-Serial\-Port\ &&\f[]
.PD 0
.P
.PD
\f[C]sleep\ 3\ &&\f[]
.PD 0
.P
.PD
.PD 0
.P
.PD
\f[C]#\ set\ time\ of\ parsivel:\f[]
.PD 0
.P
.PD
\f[C]#sudo\ hwclock\ \-s\ &&\f[]
.PD 0
.P
.PD
\f[C]#echo\ $(TZ=\f[]\[lq]\f[C]UTC\-1\f[]\[rq]\f[C]\ date\ +"%H:%M:%S")\ >\ /home/pi/testlog.txt\ &&\f[]
.PD 0
.P
.PD
\f[C]echo\ \f[]\[lq]\f[C]set\f[] \f[C]date\f[] \f[C]to\f[]
\f[C]$(date\f[] \f[C]+%d.%m.%Y)\f[]\[rq]\f[C]\ &&\f[]
.PD 0
.P
.PD
\f[C]echo\ \-e\ \f[]\[lq]\f[C]CS/D/$(date\f[]
\f[C]+%d.%m.%Y)\\r\f[]\[rq]\f[C]\ >\ /dev/USB\-Serial\-Port\ &&\f[]
.PD 0
.P
.PD
\f[C]sleep\ 3\ &&\f[]
.PD 0
.P
.PD
\f[C]echo\ \f[]\[lq]\f[C]set\f[] \f[C]time\f[] \f[C]to\f[]
\f[C]$(TZ=UTC\-1\f[] \f[C]date\f[] \f[C]+%H:%M:%S)\f[]\[rq]\f[C]\ &&\f[]
.PD 0
.P
.PD
\f[C]echo\ \-e\ \f[]\[lq]\f[C]CS/T/$(TZ=UTC\-1\f[] \f[C]date\f[]
\f[C]+%H:%M:%S)\\r\f[]\[rq]\f[C]\ >\ /dev/USB\-Serial\-Port\ &&\f[]
.PD 0
.P
.PD
\f[C]sleep\ 1\ &&\f[]
.PD 0
.P
.PD
.PD 0
.P
.PD
\f[C]#\ Anwendertelegramm\ anschalten:\f[]
.PD 0
.P
.PD
\f[C]echo\ \f[]\[lq]\f[C]switch\f[] \f[C]to\f[] \f[C]user\f[]
\f[C]data\f[] \f[C]telegram\f[]\[rq]\f[C]\ &&\f[]
.PD 0
.P
.PD
\f[C]echo\ \-e\ \f[]\[lq]\f[C]CS/M/M/1\\r\f[]\[rq]\f[C]\ >\ /dev/USB\-Serial\-Port\ &&\f[]
.PD 0
.P
.PD
\f[C]sleep\ 1\ &&\f[]
.PD 0
.P
.PD
.PD 0
.P
.PD
\f[C]#\ Datentelegramm\ festlegen:\f[]
.PD 0
.P
.PD
\f[C]echo\ \f[]\[lq]\f[C]define\f[] \f[C]data\f[]
\f[C]telegram\f[]\[rq]\f[C]\ &&\f[]
.PD 0
.P
.PD
\f[C]echo\ \-e\ \f[]\[lq]\f[C]CS/M/S/\\r\f[]\[rq]\f[C]\ >\ /dev/USB\-Serial\-Port\ &&\f[]
.PD 0
.P
.PD
\f[C]sleep\ 1\ &&\f[]
.PD 0
.P
.PD
\f[C]echo\ \-e\ "%21;%20;%01;%02;%11;%10;%12;%17;%03;%04;%05;%06;%07;%09;%08;%18;%90;%91;%93;/n\\r"\ >\ /dev/USB\-Serial\-Port\ &&\f[]
.PD 0
.P
.PD
\f[C]sleep\ 1\ &&\f[]
.PD 0
.P
.PD
.PD 0
.P
.PD
\f[C]#\ Messintervall\ auf\ 60\ Sekunden:\f[]
.PD 0
.P
.PD
\f[C]echo\ \f[]\[lq]\f[C]set\f[] \f[C]sample\f[]
\f[C]interval\f[]\[rq]\f[C]\ &&\f[]
.PD 0
.P
.PD
\f[C]echo\ \-e\ \f[]\[lq]\f[C]CS/I/60\\r\f[]\[rq]\f[C]\ >\ /dev/USB\-Serial\-Port\ &&\f[]
.PD 0
.P
.PD
\f[C]sleep\ 1\ &&\f[]
.PD 0
.P
.PD
\f[C]#\ Return\ nicht\ mehr\ in\ logdatei\ schreiben\f[]
.PD 0
.P
.PD
\f[C]kill\ $pid\ &&\f[]
.PD 0
.P
.PD
.PD 0
.P
.PD
\f[C]#\ Daten\ in\ Datei\ speichern\f[]
.PD 0
.P
.PD
\f[C](\f[]
.PD 0
.P
.PD
\f[C]cat\ /dev/USB\-Serial\-Port\ >>\ /home/pi/Documents/Loggerdaten/Loggerdaten.txt\ &\f[]
.PD 0
.P
.PD
\f[C]logging=$!\ &&\f[]
.PD 0
.P
.PD
\f[C]echo\ \f[]\[lq]\f[C]started\f[] \f[C]logging\f[] \f[C]with\f[]
\f[C]PID\f[] \f[C]$logging\f[]\[rq]
.PD 0
.P
.PD
\f[C])\ &&\f[]
.PD 0
.P
.PD
\f[C]exit\ 0\f[]
.SS usb\-serial\-remove.sh
.PP
Wird aufgerufen beim abziehen des Seriellen Adapters.
Garantiert, dass beim nächsten Anstecken die Verbindung wieder
hergestellt werden kann
.PP
\f[C]#!/bin/bash\f[]
.PD 0
.P
.PD
\f[C]echo\ \-e\ "\\nserial\ connector\ removed"\ $(date\ +"%F\ %X")\ >>\ /home/pi/logs/usb\-serial\-log.log\ &&\f[]
.PD 0
.P
.PD
\f[C]pkill\ cat\ &&\f[]
.PD 0
.P
.PD
\f[C]exit\ 0\f[]
.SS Real Time Clock
.PP
Damit der Raspberry auch ohne Internet\-Verbindung die richtige Zeit
behält, ist eine Real Time Cloc (RTC) notwendig, die man auf einem
kleinen Chip kaufen kann, der auf die GPIO\-Pins des Raspberrys
aufgesteckt wird.
Ich hab
diese (http://www.ebay.de/itm/331215053208?_trksid=p2059210.m2749.l2649&ssPageName=STRK%3AMEBIDX%3AIT)
gekauft.
Hier (http://nicegear.co.nz/blog/using-an-i2c-real-time-clock-rtc-with-a-raspberry-pi/)
habe ich eine Anleitung gefunden, um den Raspberry auf die RTC
einzustellen.
Konkret habe ich verwendet:
.PP
\f[C]#\ Remove\ the\ module\ blacklist\ entry\ so\ it\ can\ be\ loaded\ on\ boot\f[]
.PD 0
.P
.PD
\f[C]sudo\ sed\ \-i\ \[aq]s/blacklist\ i2c\-bcm2708/#blacklist\ i2c\-bcm2708/\[aq]\ /etc/modprobe.d/raspi\-blacklist.conf\f[]
.PD 0
.P
.PD
\f[C]#\ Load\ the\ module\ now\f[]
.PD 0
.P
.PD
\f[C]sudo\ modprobe\ i2c\-bcm2708\f[]
.PD 0
.P
.PD
\f[C]#\ Notify\ Linux\ of\ the\ Dallas\ RTC\ device\f[]
.PD 0
.P
.PD
\f[C]echo\ ds1307\ 0x68\ |\ sudo\ tee\ /sys/class/i2c\-adapter/i2c\-1/new_device\f[]
.PD 0
.P
.PD
\f[C]#\ Test\ whether\ Linux\ can\ see\ our\ RTC\ module.\f[]
.PD 0
.P
.PD
\f[C]sudo\ hwclock\f[]
.PP
Eine neue Real\-Time\-Clock muss man wahrscheinlich erstmal auf die
richtige Uhrzeit einstellen.
Dazu am besten den Raspberry einmal mit Internetverbindung booten, damit
er sich die Zeit aus dem Internet holt.
Dann mit folgendem Befehl die RTC einstellen:
.PP
\f[C]sudo\ hwclock\ \-w\f[]
.PP
Nun muss noch eingestellt werden, dass beim nächsten Booten die
Systemzeit von der RTC geholt wird:
.PP
\f[C]#\ Add\ the\ RTC\ device\ on\ boot\f[]
.PD 0
.P
.PD
\f[C]sudo\ sed\ \-i\ \[aq]s#^exit\ 0$#echo\ ds1307\ 0x68\ >\ /sys/class/i2c\-adapter/i2c\-1/new_device#\[aq]\ /etc/rc.local\f[]
.PD 0
.P
.PD
\f[C]echo\ \f[]\[lq]\f[C]sudo\f[] \f[C]hwclock\f[]
\f[C]\-s\f[]\[rq]\f[C]\ |\ sudo\ tee\ \-a\ /etc/rc.local\f[]
.PD 0
.P
.PD
\f[C]echo\ exit\ 0\ |\ sudo\ tee\ \-a\ /etc/rc.local\f[]
